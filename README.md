# BoxNesting

Given a set of boxes where each box has a height, length and depth between 0.5m and 1m this programs finds the most efficient way to stack them together so space consumption is optimized.

# Usage
```
usage: box_nesting [options]
  basic user options:
    -h --help   show this message
    -v --version        show version

when no options are specified program waits for input of boxes on stdin in the following format:

<n>
<length of first side of first box> <length of second side of first box> <length of third side of first box>
<length of first side of second box> <length of second side of second box> <length of third side of second box>
...
<length of first side of nth box> <length of second side of nth box> <length of third side of nth box>

where n is positive integer and the lengths are decimal numbers between 0.5 and 1

Example:
4
0.9 0.9 0.9
0.8 0.8 0.8
0.7 0.7 0.7
0.6 0.6 0.6

once specifications are given program will calculate the most efficient way to stack those boxes and write the amount of visible boxes to stdout as a single number
```

# Compilation

CMake is the build system generator. There are several configuration and targets that can be configured via cmake. You pay for what you use so any listed dependencies on a target will only be required if you actually enable it. Below each separate configuration is explained. You can any of the ways by adding multiple cmake flags.

## Code
To build the code gcc-7.3.0 is required however it should work with any compiler that has C++17 support. Only tested on ubuntu but it should work on windows as well.

By default this target is generated by cmake with having to explicitly enable it. So to just build the code cmake has to be ran and then make.

Example usage:

```
> mkdir build && cd build
> cmake ../
> make
```

Now the executable will be available in `build/src/BoxNesting`

## Test
The project uses the catch2 testing framework. The build is tested with version 2.4.2 but it should work with any version >= 2.0.0

To enable testing the `-DTEST:BOOL=ON` has to be passed to cmake. Subsequentally the `test` target is available on the resulting make file and the test executable will be build when building the code.

Example usage:

```
> mkdir build && cd build
> cmake ../ -DTEST:BOOL=ON
> make
> make test
```

## Clang-format
Formatting is done by clang-format, tested with version 6.0.0. The build system includes a handy way to call it without having to configure it yourself. When ` -DFORMAT:BOOL=ON` is passed to Cmake two additional targets will be available on the resulting make file. `format` and `format_check`, `format` will format the project in place and `format_check` will just check the formatting and show problems in the console.

Example usage:

```
> mkdir build && cd build
> cmake ../ -DTEST:FORMAT=ON
> make format_check
> make format
```

## Clang-tidy
Clang-tidy is used to ensure a higher code quality and to avoid common code smells, tested with version 6.0.0. There is no specific clang-tidy target since when it is enabled the code will be checked during normal compilation.

Example usage:

```
> mkdir build && cd build
> cmake ../ -DCLANG_TIDY:BOOL=ON
> make
```

## Flawfinder
Flawfinder is a static checked which is also used to ensure a higher code quality, tested with version 2.0.7. There is a specific target for this checked since it's not ran while building the code.

```
> mkdir build && cd build
> cmake ../ -DFLAWFINDER=ON
> make
```

## Sanitizer
 
## Code coverage

## Doxygen
